import { fs_p, path_join, path_basename } from './_builtins.jsy'

const _lsdir_file = root =>
  `all-${path_basename(root)}.json`

const _lsdir_from_str = root => @:
  root, file: _lsdir_file(root), accept: @=> true

export async function bind_lsdir(options, lsdir_list) ::
  options.add_lsdir = add_lsdir

  if ! Array.isArray(lsdir_list) ::
    lsdir_list = [lsdir_list]

  return lsdir_list.map(add_lsdir)

  function add_lsdir(lsdir) ::
    lsdir = bind_update_lsdir @
      lsdir, options.notify_changed

    lsdir.update()

    if options.reload ::
      options.bind_watcher @ options,
        [lsdir.root], lsdir.update

    return lsdir


export function as_lsdir_obj(lsdir) ::
  if 'string' === typeof lsdir ::
    lsdir = @{} root: lsdir

  let {root, file, accept, on_refresh} = lsdir

  if ! file ::
    file = `all-${path_basename(root)}.json`

  if ! accept ::
    let ext = lsdir.extensions || lsdir.ext
    if ext ::
      if 'string' === typeof ext ::
        ext = ext.split(/\s+/)
      const extensions = new Set(ext)
      accept = fname => extensions.has(fname)
    else ::
      accept = fname => fname && '.' !== fname[0]

  if ! on_refresh :: on_refresh = v=>v

  return @{} ...lsdir, root, file, accept, on_refresh


export function bind_update_lsdir(lsdir, on_changed) ::
  const {root, file, accept, on_refresh} =
    lsdir = as_lsdir_obj(lsdir)

  const _as_ls_entry = fname => @:
    fname, path: path_join(root, fname)

  let tip = [{}]

  lsdir.update = update_lsdir
  return lsdir

  async function update_lsdir() ::
    let raw_docs = fs_p.readdir(root)
    try :: raw_docs = await raw_docs
    catch err :: return

    const ls_docs = raw_docs.filter(accept).sort()

    if vec_eq(tip, ls_docs) ::
      return // avoid writing when unchanged
    tip = ls_docs

    const entries = on_refresh @
      ls_docs.map @ _as_ls_entry

    if undefined !== entries ::
      await fs_p.writeFile @ file,
        JSON.stringify @ entries, null, 2
      on_changed()


function vec_eq(a, b) ::
  const len = a.length
  if len !== b.length :: return false
  for let i=0; i<len; i++ ::
    if a[i] != b[i] :: return false
  return true

